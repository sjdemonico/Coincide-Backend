module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    input pulseA,
    input pulseB,
    input pulseC,
    input pulseD
  ) {
  
  sig rst;                  // reset signal
  sig ctr_rst;
  const CLKSPEED = 135000000;
  
  medclk fast(.CLK_IN1(clk));
  .clk(fast.CLK_OUT1) {
    reset_conditioner reset_cond;
    dff counts[30][24](.rst(ctr_rst)); //accumulators, every 1/10sec copied to count_store, then zeroed
    .rst(rst){
      // the avr_interface module is used to talk to the AVR for access to the USB port and analog pins
      avr_interface avr(#CLK_FREQ(CLKSPEED));
      //reg_interface reg(#CLK_FREQ(CLKSPEED));
      timer tmr(#SIZE($clog2(CLKSPEED/10)),#TOP((CLKSPEED/10) - 1));
      dff pins[2][4]; //duplicated pulses live here; low 4 bits for window X, high 4 for window Y
      dff pulse_length[2][4]; //number of cycles duplicated pulses live for; low 4 bits for window X, high 4 for window Y
      dff count_store[30][24]; //storage registers for counts, outputs go to shift register
      fsm state = {COUNT,BLIND};
      serialbuffer buff(.count_store(count_store.q));
      
      //pulse duplicators instantiated; 4 channels, 2 for each channel, one per window (X and Y)
      duplicator xdupA(.length(pulse_length.q[0]));
      duplicator xdupB(.length(pulse_length.q[0]));
      duplicator xdupC(.length(pulse_length.q[0]));
      duplicator xdupD(.length(pulse_length.q[0]));
      duplicator ydupA(.length(pulse_length.q[1]));
      duplicator ydupB(.length(pulse_length.q[1]));
      duplicator ydupC(.length(pulse_length.q[1]));
      duplicator ydupD(.length(pulse_length.q[1]));
      
      //channel comparators instantiated; 30 comparators, 2 for each comparison, one per window (X and Y)
      comparator xcompA(.length(pulse_length.q[0]));
      comparator xcompB(.length(pulse_length.q[0]));
      comparator xcompC(.length(pulse_length.q[0]));
      comparator xcompD(.length(pulse_length.q[0]));
      comparator xcompAB(.length(pulse_length.q[0]));
      comparator xcompAC(.length(pulse_length.q[0]));
      comparator xcompAD(.length(pulse_length.q[0]));
      comparator xcompBC(.length(pulse_length.q[0]));
      comparator xcompBD(.length(pulse_length.q[0]));
      comparator xcompCD(.length(pulse_length.q[0]));
      comparator xcompABC(.length(pulse_length.q[0]));
      comparator xcompABD(.length(pulse_length.q[0]));
      comparator xcompACD(.length(pulse_length.q[0]));
      comparator xcompBCD(.length(pulse_length.q[0]));
      comparator xcompABCD(.length(pulse_length.q[0]));
      comparator ycompA(.length(pulse_length.q[1]));
      comparator ycompB(.length(pulse_length.q[1]));
      comparator ycompC(.length(pulse_length.q[1]));
      comparator ycompD(.length(pulse_length.q[1]));
      comparator ycompAB(.length(pulse_length.q[1]));
      comparator ycompAC(.length(pulse_length.q[1]));
      comparator ycompAD(.length(pulse_length.q[1]));
      comparator ycompBC(.length(pulse_length.q[1]));
      comparator ycompBD(.length(pulse_length.q[1]));
      comparator ycompCD(.length(pulse_length.q[1]));
      comparator ycompABC(.length(pulse_length.q[1]));
      comparator ycompABD(.length(pulse_length.q[1]));
      comparator ycompACD(.length(pulse_length.q[1]));
      comparator ycompBCD(.length(pulse_length.q[1]));
      comparator ycompABCD(.length(pulse_length.q[1]));

    }
  }
  
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    buff.drdy = 0; //shifter defaults to 0 (IDLE)
    led = counts.q[0][7:0]; //debug
    ctr_rst = 0;
    
    //pulse duplicator connections in
    xdupA.pulse = pulseA;
    xdupB.pulse = pulseB;
    xdupC.pulse = pulseC;
    xdupD.pulse = pulseD;
    ydupA.pulse = pulseA;
    ydupB.pulse = pulseB;
    ydupC.pulse = pulseC;
    ydupD.pulse = pulseD;
    //pulse duplicator connections out
    pins.d[0][0] = xdupA.out;
    pins.d[0][1] = xdupB.out;
    pins.d[0][2] = xdupC.out;
    pins.d[0][3] = xdupD.out;
    pins.d[1][0] = ydupA.out;
    pins.d[1][1] = ydupB.out;
    pins.d[1][2] = ydupC.out;
    pins.d[1][3] = ydupD.out;
    
    //comparator connections in; 4-way AND gates with channels not being considered held HIGH by OR mask
    xcompA.pins = (pins.q[0] | b1110);
    xcompB.pins = (pins.q[0] | b1101);
    xcompC.pins = (pins.q[0] | b1011);
    xcompD.pins = (pins.q[0] | b0111);
    xcompAB.pins = (pins.q[0] | b1100);
    xcompAC.pins = (pins.q[0] | b1010);
    xcompAD.pins = (pins.q[0] | b0110);
    xcompBC.pins = (pins.q[0] | b1001);
    xcompBD.pins = (pins.q[0] | b0101);
    xcompCD.pins = (pins.q[0] | b0011);
    xcompABC.pins = (pins.q[0] | b1000);
    xcompABD.pins = (pins.q[0] | b0100);
    xcompACD.pins = (pins.q[0] | b0010);
    xcompBCD.pins = (pins.q[0] | b0001);
    xcompABCD.pins = (pins.q[0] | b0000);
    ycompA.pins = (pins.q[1] | b1110);
    ycompB.pins = (pins.q[1] | b1101);
    ycompC.pins = (pins.q[1] | b1011);
    ycompD.pins = (pins.q[1] | b0111);
    ycompAB.pins = (pins.q[1] | b1100);
    ycompAC.pins = (pins.q[1] | b1010);
    ycompAD.pins = (pins.q[1] | b0110);
    ycompBC.pins = (pins.q[1] | b1001);
    ycompBD.pins = (pins.q[1] | b0101);
    ycompCD.pins = (pins.q[1] | b0011);
    ycompABC.pins = (pins.q[1] | b1000);
    ycompABD.pins = (pins.q[1] | b0100);
    ycompACD.pins = (pins.q[1] | b0010);
    ycompBCD.pins = (pins.q[1] | b0001);
    ycompABCD.pins = (pins.q[1] | b0000);
            
    // connect inputs of avr
    avr.cclk = cclk;
    avr.spi_ss = spi_ss;
    avr.spi_mosi = spi_mosi;
    avr.spi_sck = spi_sck;
    avr.rx = avr_tx;
    avr.channel = hf;           // ADC is unused so disable
    avr.tx_block = avr_rx_busy; // block TX when AVR is busy
    
    // connect outputs of avr
    spi_miso = avr.spi_miso;
    spi_channel = avr.spi_channel;
    avr_rx = avr.tx;
    
    // connect serial buffer to avr interface
    avr.tx_data = buff.tx_data_out;
    avr.new_tx_data = buff.new_tx_out;
    buff.tx_busy_out = avr.tx_busy;
    buff.drdy = 0; 
   
    // updating pulse length; by default, any incoming byte encodes desired pulse lengths for X(lower 4) and Y(upper 4)
    if(avr.new_rx_data) {
      pulse_length.d[0] = avr.rx_data[3:0];
      pulse_length.d[1] = avr.rx_data[7:4];
    }  
        
    case(state.q) {
      state.COUNT:
         
        //counter behavior; must be top level! counters reset inconsistently when embedded in comparator module
        if(xcompA.incr) counts.d[0] = counts.q[0] + 1;
        if(xcompB.incr) counts.d[1] = counts.q[1] + 1;
        if(xcompC.incr) counts.d[2] = counts.q[2] + 1;
        if(xcompD.incr) counts.d[3] = counts.q[3] + 1;
        if(xcompAB.incr) counts.d[4] = counts.q[4] + 1;
        if(xcompAC.incr) counts.d[5] = counts.q[5] + 1;
        if(xcompAD.incr) counts.d[6] = counts.q[6] + 1;
        if(xcompBC.incr) counts.d[7] = counts.q[7] + 1;
        if(xcompBD.incr) counts.d[8] = counts.q[8] + 1;
        if(xcompCD.incr) counts.d[9] = counts.q[9] + 1;
        if(xcompABC.incr) counts.d[10] = counts.q[10] + 1;
        if(xcompABD.incr) counts.d[11] = counts.q[11] + 1;
        if(xcompACD.incr) counts.d[12] = counts.q[12] + 1;
        if(xcompBCD.incr) counts.d[13] = counts.q[13] + 1;
        if(xcompABCD.incr) counts.d[14] = counts.q[14] + 1;
        if(ycompA.incr) counts.d[15] = counts.q[15] + 1;
        if(ycompB.incr) counts.d[16] = counts.q[16] + 1;
        if(ycompC.incr) counts.d[17] = counts.q[17] + 1;
        if(ycompD.incr) counts.d[18] = counts.q[18] + 1;
        if(ycompAB.incr) counts.d[19] = counts.q[19] + 1;
        if(ycompAC.incr) counts.d[20] = counts.q[20] + 1;
        if(ycompAD.incr) counts.d[21] = counts.q[21] + 1;
        if(ycompBC.incr) counts.d[22] = counts.q[22] + 1;
        if(ycompBD.incr) counts.d[23] = counts.q[23] + 1;
        if(ycompCD.incr) counts.d[24] = counts.q[24] + 1;
        if(ycompABC.incr) counts.d[25] = counts.q[25] + 1;
        if(ycompABD.incr) counts.d[26] = counts.q[26] + 1;
        if(ycompACD.incr) counts.d[27] = counts.q[27] + 1;
        if(ycompBCD.incr) counts.d[28] = counts.q[28] + 1;
        if(ycompABCD.incr) counts.d[29] = counts.q[29] + 1;
            
        //timer behavior; copy and zero counters
        if(tmr.maxval) state.d = state.BLIND;
        
      state.BLIND:  
        count_store.d = counts.q;
        ctr_rst = 1;
        buff.drdy = 1;
        state.d = state.COUNT;    
    }
  }
}